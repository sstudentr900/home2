<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/customPrism.css">
  <link rel="stylesheet" href="../css/customPrism.css">
  <link rel="stylesheet" href="../css/prism.css">
  <script src="../js/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body id="program">
  <h2>各板本變數</h2>
  <pre class="prettyprint">
    <xmp>
      //Vue2 data內放變數
      data: {
        msg: 'Hello World'
      }

      //Vue3 setup內放變數,需要return
      setup() {
        const msg = ref('Hello World');
        return { msg }
      }

      //vite 搭配setup不用return
      <script setup>
        const msg = ref('Hello World');
      </script>
    </xmp>
  </pre>

  <h2>ref()</h2>
  <ul>
    <li>ref 可以包任何型別</li>
    <li>ref 包裝該值讓他有響應試</li>
    <li>ref 是obj請用const</li>
    <li>ref 被包裝後，要用.value才能取值</li>
  </ul>
  <pre class="prettyprint">
    <xmp>
      <template>
        <h1>vue: {{ count }}</h1>
        <button @click="increment"> count is: {{ count }}</button>
      </template>
      <script>
        const count = ref(0); 
        const increment = ()=>{
          //count 被包裝後需要用.value才能取值
          console.log(count)
          count.value += 1;
        }
      </script>
    </xmp>
  </pre>

  <h2>reactive()</h2>
  <ul>
    <li>reactive 只可以包{}和[]</li>
  </ul>
  <pre class="prettyprint">
    <xmp>
      <template>
        <h1>vue: {{ data }}</h1>
      </template>
      <script>
        const data = reactive({
          name: 'mike'
        }); 
        setTimeout(()=>{
          data.name = 'jacky'
        },2000)
      </script>
    </xmp>
  </pre>

  <h2>ref vs reactive</h2>
  <p>ref 取值需要加.value</p>
  <p>watch 觀看ref(object) 深度不會被監聽</p>
  <pre class="prettyprint">
    <xmp>
      <script setup>
        import { ref, reactive,watch } from 'vue';
        //ref包入object時watch不能被監聽
        const people = ref(0);
        const people1 = ref({
          num: 0,
        });
        const people2 = reactive({
          num: 0,
        });
        setTimeout(() => {
          people.value = 50;
          people1.value.num = 100;
          people2.num = 200;
        }, 2000);
        watch(people,()=>{
          console.log('people被監聽')
        })
        watch(people1,()=>{
          console.log('people1不能被監聽')
        })
        watch(people1,()=>{
          console.log('people1有deep可以被監聽')
        },{deep: true})
        watch(people2,()=>{
          console.log('people2被監聽')
        })

        //reactive 會解包 ref
        const num = ref(0);
        const people3 = reactive({
          num: num,
        });
        setTimeout(() => {
          //不需要.value
          people3.num = 300;
        }, 2000);
      </script>
      <template>
        <h1>{{ people }}</h1>
        <h1>{{ people1 }}</h1>
        <h1>{{ people2 }}</h1>
        <h1>{{ people3 }}</h1>
      </template>
    </xmp>
  </pre>
  <h4>參考</h4>
  <ul>
    <li>
      <a href="https://vuejs.org/tutorial/#step-2" target="_blank">vue 官網</a>
    </li>
    <li>
      <a href="https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project" target="_blank">vite 官網</a>
    </li>
    <li>
      <a href="https://stackoverflow.com/questions/61452458/ref-vs-reactive-in-vue-3" target="_blank">ref vs reactive</a>
    </li>
    <li>
      <a href="https://www.youtube.com/watch?v=rNQIA0Fe9KQ&ab_channel=MikeCheng" target="_blank">Vue3 + Vite 快速上手</a>
    </li>
  </ul>
</body>

</html>